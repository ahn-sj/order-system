# 주문 시스템 - 제품 요구사항 명세서 (PRD)

## 1. TL;DR
주문 처리 과정에서 DB 저장과 이벤트 발행 간 불일치를 방지하고, 장애 상황에서도 멱등성과 순서를 보장하기 위해 **Outbox 패턴**을 도입하여 안정적인 주문 이벤트 흐름을 확보한다.  

---

## 2. 문제 정의 (Problem)
현재 주문 시스템은 **DB 트랜잭션과 Kafka 발행 간 원자성 보장이 어렵다**는 문제가 있다.  

1. **현상**
   - 주문 데이터는 DB에 저장되었으나, 이벤트 발행이 실패하는 경우 → **소비자 서비스에서 주문이 누락됨**  
   - Kafka 발행은 성공했으나 DB 트랜잭션이 롤백되는 경우 → **소비자 서비스에서 잘못된 주문이 처리됨**  

2. **문제 원인**
   - DB 트랜잭션과 Kafka 발행은 서로 다른 시스템이므로 **분산 트랜잭션 불가**  
   - 네트워크 지연, 장애, 애플리케이션 재시작 시 **이벤트 유실·중복 발생 가능성**  

3. **영향**
   - 결제, 배송 등 다운스트림 서비스에서 **잘못된 주문 상태**를 기반으로 로직 실행  
   - CS 및 운영 부서의 **오류 처리 비용 증가**  
   - 장기적으로 **고객 신뢰 하락 및 SLA 위반 리스크**  

---

## 3. 용어집 (Glossary)
- **Outbox 패턴**: DB 트랜잭션 내에 이벤트를 함께 저장하고, 별도 프로세스가 이벤트를 읽어 발행하는 패턴  
- **PENDING**: 발행 대기 상태  
- **COMPLETED**: 발행 완료 상태  
- **QUARANTINED**: 반복 실패로 격리된 상태  
- **멱등성(Idempotency)**: 동일 이벤트가 여러 번 발행·소비되어도 최종 결과가 변하지 않도록 하는 성질  

---

## 4. 솔루션 (Solution)
### 제안 솔루션: Outbox 패턴 + Kafka 기반 이벤트 발행
1. **DB 트랜잭션과 이벤트 기록을 원자적으로 보장**  
   - 주문 생성과 동시에 Outbox 테이블에 이벤트 기록  
2. **Polling 기반 발행 모듈**  
   - Outbox의 `PENDING` 이벤트를 주기적으로 조회 후 Kafka 발행  
   - 성공 시 `COMPLETED`, 실패 시 재시도 → 반복 실패 시 `QUARANTINED`  
3. **순서 보장 및 멱등성 처리**  
   - Kafka 파티션 키를 주문 ID로 설정해 순서 보장  
   - 이벤트 ID 기반 중복 처리로 멱등성 확보  

### 대안 고려
- **이중 쓰기(Direct Publish + DB)**: 간단하나 원자성 불보장  
- **분산 트랜잭션 (XA, 2PC)**: 복잡성과 성능 저하 → 부적합  
- **체인지 데이터 캡처(CDC)**: 운영 DB 부하 및 운영 복잡성 증가  

> 현재 선택 솔루션: **Outbox 패턴** (Spring Boot + Kafka + MySQL)  

### 요구사항
- 언어/프레임워크: Java + Spring Boot  
- 메시지 브로커: Apache Kafka  
- DB: MySQL  
- 장애 대응: Outbox Polling + 재시도 + 격리 처리  
- 파티션 전략: 주문 ID 기반  

---

## 5. 성공 지표 (Success Metrics)

### 5.1 정량 지표
- 이벤트 유실률: **0%**  
- 이벤트 순서 오류 발생률: **0%**  
- 평균 이벤트 발행 지연: **3초 이내**  
- 전체 주문 처리 시간(생성 → 발행 → 소비 완료): **1분 이내**  

### 5.2 정성 지표
- 운영자가 “주문 이벤트 불일치로 인한 장애 대응”을 하지 않아도 되는 상태  
- 개발자가 “이벤트 순서·중복 처리”를 별도로 고려하지 않아도 되는 개발 경험 제공  

---

## 6. 예시 시나리오
### 6.1 정상 흐름
1. 주문 생성 → Outbox(`PENDING`) → 발행 성공 → `COMPLETED`  

### 6.2 발행 실패 → 격리
1. 주문 생성 → 발행 실패(6회 재시도) → `QUARANTINED`  
